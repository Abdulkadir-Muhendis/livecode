/*  
This library consists of the operations on bytes included in the standard library of modular LiveCode.
*/

module com.livecode.byte

public foreign handler EvalNumberOfBytesIn(in Target as data, out Count as index) as undefined binds to "<builtin>"

public foreign handler EvalOffsetOfBytes(in IsLast as bool, in Needle as data, in Target as data, out Offset as index) as undefined binds to "<builtin>"
public foreign handler EvalOffsetOfBytesBefore(in IsLast as bool, in Needle as data, in Before as index, in Target as data, out Offset as index) as undefined binds to "<builtin>"
public foreign handler EvalOffsetOfBytesAfter(in IsFirst as bool, in Needle as data, in After as index, in Target as data, out Offset as index) as undefined binds to "<builtin>"

public foreign handler EvalIsAmongTheBytesOf(in Needle as data, in Target as data, out Value as bool) as undefined binds to "<builtin>"

public foreign handler EvalContainsBytes(in Target as data, in Needle as data, out Value as bool) as undefined binds to "<builtin>"
public foreign handler EvalIsInBytes(in Needle as data, in Target as data, out Value as bool) as undefined binds to "<builtin>"
public foreign handler EvalBeginsWithBytes(in Target as data, in Needle as data, out Value as bool) as undefined binds to "<builtin>"
public foreign handler EvalEndsWithBytes(in Target as data, in Needle as data, out Value as bool) as undefined binds to "<builtin>"

public foreign handler FetchByteOf(in Index as index, in Target as data, out Value as data) as undefined binds to "<builtin>"
public foreign handler StoreByteOf(in Value as data, in Index as index, inout Target as data) as undefined binds to "<builtin>"
public foreign handler FetchByteRangeOf(in Start as index, in Finish as index, in Target as data, out Value as data) as undefined binds to "<builtin>"
public foreign handler StoreByteRangeOf(in Value as data, in Start as index, in Finish as index, inout Target as data) as undefined binds to "<builtin>"

public foreign handler StoreBeforeByteOf(in Value as data, in Index as index, inout Target as data) as undefined binds to "<builtin>"
public foreign handler StoreAfterByteOf(in Value as data, in Index as index, inout Target as data) as undefined binds to "<builtin>"

--

/*
Summary:            Counts the number of bytes in <Target>.

Target: 			An expression which evaluates to binary data.

Example: 			

	repeat with x = 1 to the number of bytes in tData
		// do something
	end repeat
*/

syntax CountBytesOf is prefix operator with precedence 1
	"the" "number" "of" "bytes" "in" <Target: Expression>
begin
	EvalNumberOfBytesIn(Target, output)
end syntax

--

/*

Summary:            Finds the first or last occurrence of <Needle> within <Target>

Needle: 			An expression which evaluates to binary data.
Target: 			An expression which evaluates to binary data.
output:             Returns the offset of <Needle> in <Target>.

Description:
The first (respectively last) offset of <Needle> in <Target> is number of bytes between the first byte of <Target> and the first (respectively last) occurrence of <Needle>. If neither first or last is specified, then the first offset is found. If <Needle> does not occur in <Target>, then the output is 0.

*/

syntax ByteOffset is prefix operator with precedence 1
    "the" ( "first" <IsLast=false> | "last" <IsLast=true> | <IsLast=false> ) "offset" "of" "bytes" <Needle: Expression> "in" <Target: Expression>
begin
    EvalOffsetOfBytes(IsLast, Needle, Target, output)
end syntax

/*

Summary:            Finds the first or last occurrence of <Needle> after a specified index in <Target>

Needle: 			An expression which evaluates to binary data.
Target: 			An expression which evaluates to binary data.
After:              An expression which evaluates to a valid integer index of Target.
output:             Returns the offset of <Needle> after index <After> in <Target>.
                    
Description:
The first (respectively last) offset of <Needle> in <Target> is number of bytes between byte <After> of <Target> and the first (respectively last) occurrence of <Needle> after <After>. If neither first or last is specified, then the first offset is found. If <Needle> does not occur after <After> in <Target>, then the output is 0.
*/

syntax ByteOffsetAfter is prefix operator with precedence 1
	"the" ( "first" <IsLast=false> | "last" <IsLast=true> | <IsLast=false> ) "offset" "of" "bytes" <Needle: Expression> "after" <After: Expression> "in" <Target: Expression>
begin
	EvalOffsetOfBytesAfter(IsLast, Needle, After, Target, output)
end syntax

/*

Summary:            Finds the first or last occurrence of <Needle> before a specified index in <Target>.

Needle: 			An expression which evaluates to binary data.
Target: 			An expression which evaluates to binary data.
After:              An expression which evaluates to a valid integer index of Target.
output:             Returns the offset of <Needle> before index <Before> in <Target>.
                    
Description:
The first (respectively last) offset of <Needle> in <Target> is number of bytes between the first byte of <Target> and the first (respectively last) occurrence of <Needle> before <Before>. If neither first or last is specified, then the last offset is found. If <Needle> does not occur before <Before> in <Target>, then the output is 0.

*/

syntax ByteOffsetBefore is prefix operator with precedence 1
    "the" ( "first" <IsFirst=true> | "last" <IsFirst=false> | <IsFirst=false> ) "offset" "of" "bytes" <Needle: Expression> "before" <Before: Expression> "in" <Target: Expression>
begin
    EvalOffsetOfBytesBefore(IsFirst, Needle, Before, Target, output)
end syntax

/*
Summary:            Determines whether <Needle> is in <Target>.
Needle: 			An expression which evaluates to a single byte of binary data.
Target: 			An expression which evaluates to binary data.
output:             True if <Needle> is among the bytes of <Target>, and false otherwise.

Description:
>*Note:* It is an error if <Needle> evaluates to data consisting of more than one byte.
*/

syntax IsAmongTheBytesOf is neutral binary operator with precedence 1
    <Needle: Expression> "is" "in" <Target: Expression>
begin
    EvalIsInBytes(Needle, Target, output)
end syntax

--

/*
Summary:            Determines whether <Needle> contains <Target>.
Needle: 			An expression which evaluates to binary data.
Target: 			An expression which evaluates to binary data.
output:             True if the bytes of <Needle> occur as a subsequence of the bytes of <Target>, and false otherwise.

Description:
>*Note:* Since the empty data is a subsequence of every sequence of bytes, every sequence of bytes contains the empty data.
*/

syntax ContainsBytes is neutral binary operator with precedence 1
    <Target: Expression> "contains" <Needle: Expression>
begin
    EvalContainsBytes(Target, Needle, output)
end syntax

/*
Summary:            Determines whether <Target> begins with <Needle>.
Needle: 			An expression which evaluates to binary data.
Target: 			An expression which evaluates to binary data.
output:             True if the bytes of <Needle> occur as an initial subsequence of the bytes of <Target>, and false otherwise.

Description:
>*Note:* Since the empty data is an initial subsequence of every sequence of bytes, every sequence of bytes begins with the empty data.
*/

syntax BeginsWithBytes is neutral binary operator with precedence 1
    <Target: Expression> "begins" "with" <Needle: Expression>
begin
    EvalBeginsWithBytes(Target, Needle, output)
end syntax

/*
Summary:            Determines whether <Target> ends with <Needle>.
Needle: 			An expression which evaluates to binary data.
Target: 			An expression which evaluates to binary data.
output:             True if the bytes of <Needle> occur as a final subsequence of the bytes of <Target>, and false otherwise.

Description:
>*Note:* Since the empty data is a final subsequence of every sequence of bytes, every sequence of bytes ends with the empty data.
*/

syntax EndsWithBytes is neutral binary operator with precedence 1
    <Target: Expression> "ends" "with" <Needle: Expression>
begin
    EvalEndsWithBytes(Target, Needle, output)
end syntax

--

/*

Summary:            Designates the byte of data at index <Index> in <Target>.
Index: 				An expression which evaluates to a valid integer index of <Target>.
Target:				An expression which evaluates to binary data.

Example: 			put the empty data into byte 5 of tData // Locates byte 5 and removes it from tData
Example: 			get byte 5 of tData // Evaluates byte 5

Description:
Either locates the byte at the given index for use as the target container of another operation, or evaluates the byte at the given index as the source of another operation.

>*Note:* It is an error if <Index> is out of range.
*/

syntax SingletonByteOf is prefix operator with precedence 1
	"byte" <Index: Expression> "of" <Target: Expression>
begin
	FetchByteOf(Index, Target, output)
	StoreByteOf(input, Index, Target)
end syntax

/*

Summary:            Designates the bytes of data between indices <Start> and <Finish> in <Target>.

Start:              An expression which evaluates to a valid integer index of <Target>.
Finish:             An expression which evaluates to a valid integer index of <Target>.
Target:             An expression which evaluates to binary data.
                    
Example: 			put tBytes into byte 5 to 10 of tData // Locates bytes 5 to 10 and replace them with tBytes
Example: 			get byte 5 to 10 of tData // Evaluates bytes 5 to 10

Description:
Either locates the bytes between the given indices for use as the target container of another operation, or evaluates the bytes at the given indices as the source of another operation.

>*Note:* It is an error if either <Start> or <Finish> are out of range.
*/

syntax RangeByteOf is prefix operator with precedence 1
	"byte" <Start: Expression> "to" <Finish: Expression> "of" <Target: Expression>
begin
	FetchByteRangeOf(Start, Finish, Target, output)
	StoreByteRangeOf(input, Start, Finish, Target)
end syntax

--

end module