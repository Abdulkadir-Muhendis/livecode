module com.livecode.GrammarExamples

////////////////////////////////////////////////////////////////////////////////
//
// Comment Forms:
//
// The following forms of comment will be admissible in MLC:
//    /* ... */ (not nested)
//    //
//    -- (TO REVIEW)

////////////////////////////////////////////////////////////////////////////////
//
// Constant definitions
//
constant MyConstant is 100

////////////////////////////////////////////////////////////////////////////////
//
// Type definitions
//

// Named type definition
//
// An identifier can be bound to another type. The other type can either
// be a named type, or one of the high-level types.
//
type MyTypeAlias is MyAny

// Opaque type definition
//
// An opaque type defines a new script type whose internals are managed by
// a collection of handlers (foreign or not). Opaque types are automatically
// boxed and unboxed when passing out of/into foreign handlers.
opaque type MyOpaqueType
    
    // The 'measure' method is called once and should return the size of the
    // opaque type in bytes.
    measure is MyOpaqueType_Measure

    // The 'initialize' method is called whenever the contents of the type
    // needs to be initialized after allocation. If this method is not supplied,
    // the contents will be filled with zeros.
    initialize is MyOpaqueType_Initialize
    
    // The 'finalize' method is called whenever the contents of the type is
    // finished with and needs cleaned up. This method is optional (i.e. if
    // the type has nothing to clean up in its contents).
    finalize is MyOpaqueType_Finalize

    // The 'move' method is called whenever the contents of the type is moved
    // in memory. If this method is not supplied, copy and finalize will be
    // used instead.
    move is MyOpaqueType_Move
    
    // The 'copy' method is called whenever the contents of the type is copied.
    // If this method is not supplied, then a byte-for-byte copy will be performed.
    copy is MyOpaqueType_Copy

    // The 'equal' method is called whenever two of the types need to be
    // compared. If this method is not supplied, a byte-for-byte comparison
    // will be performed.
    equal is MyOpaqueType_Equal
    
    // The 'hash' method is called whenever a hash value of the type is required.
    // If this method is not supplied, an unspecified byte-hash function will be
    // used on the contents.
    hash is MyOpaqueType_Hash

end type

// Methods for a 'base' opaque type are as follows. The 'contents' pointers are all
// pointers to the start of the type's allocated memory.
foreign handler MyOpaqueType_Measure() as uint binds to "<undefined>"
foreign handler MyOpaqueType_Initialize(in pContents as pointer) as undefined binds to "<undefined>"
foreign handler MyOpaqueType_Finalize(in pContents as pointer) as undefined binds to "<undefined>"
foreign handler MyOpaqueType_Move(in pOldContents as pointer, in pNewContents as pointer) as undefined binds to "<undefined>"
foreign handler MyOpaqueType_Copy(in pOldContents as pointer, in pNewContents as pointer) as undefined binds to "<undefined>"
foreign handler MyOpaqueType_Equal(in pLeftContents as pointer, in pRightContents as pointer) as bool binds to "<undefined>"
foreign handler MyOpaqueType_Hash(in pContents as pointer) as uint binds to "<undefined>"

// An opaque type can also be based on the pointer type. In this case, the parameters
// to the type's methods are the value of the pointer rather than a pointer to the
// start of the opaque type's contents.
opaque type MyPointerOpaqueType based on pointer
    initialize is MyPointerOpaqueType_Initialize
    finalize is MyPointerOpaqueType_Finalize
    move is MyPointerOpaqueType_Move
    copy is MyPointerOpaqueType_Copy
    equal is MyPointerOpaqueType_Equal
    hash is MyPointerOpaqueType_Hash
end type

// Methods for a pointer-based opaque type are as follows. Here the pointers passed are
// already dereferenced from the contents.
foreign handler MyPointerOpaqueType_Initialize(out rPointer as pointer) as undefined binds to "<undefined>"
foreign handler MyPointerOpaqueType_Finalize(in pPointer as pointer) as undefined binds to "<undefined>"
foreign handler MyPointerOpaqueType_Move(in pPointer as pointer, out pMovedPointer as pointer) as undefined binds to "<undefined>"
foreign handler MyPointerOpaqueType_Copy(in pPointer as pointer, out pCopiedPointer as pointer) as undefined binds to "<undefined>"
foreign handler MyPointerOpaqueType_Equal(in pLeft as pointer, in pRight as pointer) as bool binds to "<undefined>"
foreign handler MyPointerOpaqueType_Hash(in pLeft as pointer, in pRight as pointer) as bool binds to "<undefined>"

// Record type definition
//
// A record type is a collection of fields all stored together.
//
record type MyRecordType
    Offset as integer
    Length as integer
end type

// Handler type definition
//
// A handler type can store a handler for later invocation.
//
handler type MyHandlerType(in pBoolParam as bool, in pArrayParam as array, out rStringReturnParam as string) as integer

// High-level types
//
// These types are the 'natural' types MLC works with. When used in a
// foreign handler context it means pass the value as an MLC type (ValueRef).

// 'any' is the union of all (high-level) types
type MyAny is any

// 'boolean' is the true / false type
type MyBoolean is boolean

// 'integer' is the integral number type
type MyInteger is integer

// 'real' is the floating point number type.
type MyReal is real

// 'number' is either an integer or a real, it preserves the representation
// wherever possible, and promotes as necessary (i.e. on overflow).
type MyNumber is number

// 'string' is a sequence of unicode codepoints
type MyString is string

// 'data' is a sequence of bytes
type MyData is data

// 'array' is an associative array
type MyArray is array

// 'list' is a sequence of values, indexed starting at 1.
type MyList is list

// Low-level types
//
// These types are used to indicate types to pass to foreign handlers. Outside
// of that they can be assumed to be taken as their natural 'high-level' types.

// 'pointer' is the foreign pointer type, it has no natural representation and is
// passed around as a boxed value of unique type.
type MyPointer is pointer

// 'bool' is the foreign boolean type, it is naturally represented by 'boolean'.
type MyBool is bool

// 'int' is the foreign integer type, it is naturally represeted by 'integer'.
type MyInt is int

// 'uint' is the foreign unsigned integer type, it is naturally represented by 'integer'.
type MyUInt is uint

// 'float' is the foreign small real type, it is naturally represented by 'real'
type MyFloat is float

// 'double' is the foreign real type, it is naturally represented by 'real'
type MyDouble is double

////////////////////////////////////////////////////////////////////////////////
//
// Variable definitions
//

variable mMyAnyVariable as any
variable mMyIntegerVariable as integer
variable mMyPointerOpaqueTypeVariable as MyPointerOpaqueType

////////////////////////////////////////////////////////////////////////////////
//
// Handler definitions
//

foreign handler MyForeignStatementHandler(in pArg1 as int) binds to "MyBinding"
foreign handler MyForeignExpressionHandler(in pArg1 as int, out rReturn1 as bool) binds to "MyBinding"

handler MyHandler(in pArg1 as integer, in pArg2 as string, in pArg3 as MyHandlerType) as boolean
end handler

////////////////////////////////////////////////////////////////////////////////
//
// Syntax definitions
//

syntax MyStatementSyntax is statement
    "do" <Value: Expression> "in" "my" "own" "way"
begin
    MyForeignStatementHandler(Value)
end syntax

syntax MyExpressionSyntax is expression
    "evaluate" <Value: Expression> "specially"
begin
    MyForeignExpressionHandler(Value, output)
end syntax

end module

